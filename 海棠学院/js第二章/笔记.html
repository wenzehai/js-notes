<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
			/*
			 * 数据类型
			 *一、基本数据类型
			 *		1、字符串	String
			 * 			放在成对引号中
			 * 		2、数字		Number
			 * 			1、由0-9之间的任意数组组合而成，可以是整数，也可以是小数。数字的范围在正无穷
			 * 			(+Infinity)与负无穷（-Infinity)之间
			 * 			数字最大值：Number.MAX_VALUE
			 * 			数字最大值：Number.MIN_VALUE
			 * 			2、NaN
			 * 				Not a Number
			 * 				当运算失败时出现
			 * 				自身与自身不相等
			 * 		3、布尔值	Boolean
			 * 			true
			 * 			false
			 * 		4、未定义	Undefined
			 * 			有且只有一个值undefined			有，但是没有给值
			 * 		4、空		Null
			 * 			有且只有一个值null				压根就没有，不存在，也没有值
			 * 
			 *二、复合数据类型
			 *		对象		Object
			 * 		格式	：由简单数据类型与复合数据类型任意组合而成的。她的数据是放在一对大括号中，每个数据是由
			 * 一个键值对组合而成的，数据可以是0个，也可以是多个，每个数据之间用逗号隔开，最后一个数据不能加逗号
			 * （如果加了逗号，就会报错；数组在最后一个位置加逗号，不会报错）
			 * 			键值对： key:value
			 * 				key 数据名称，它可以加引号，也可以不加引号，当这个名字不符合变量命名规则的时候，要加上引号，
			 * 					引号是成对出现的。
			 * 				value  数据对应的值，这个值可以是简单数据类型，也可以是复杂数据类型
			 * 
			 * 		操作对象用的方法就是属性的方法
			 * 
			 * *typeof
			 * 检测一个数据的类型，返回这个类型对应的字符串（全小写）
			 * 返回的结果与系统当中定义的类型是有区别
			 * 它是一个运算符
			 * 
			 * 语法
			 * typeof 数据
			 * 
			 * 系统定义的数据类型			typeof返回的数据类型
			 * String						string
			 * Number						number
			 * Boolean						boolean
			 * Undefined					undefined
			 * Null							object
			 * Object						object
			 * 
			 * 函数的typeof结果为function,functon在系统中没有定义类型
			 * 
			 **数据类型转换
			 * 
			 * js支持把任意一种数据类型转换成以下类型
			 * 		数字
			 * 		字符串
			 * 		布尔值
			 * 		
			 * 对象转成这三种数据是没有意义，因为对象里面可以放任意一种数据类型。
			 * 
			 **把字符串转成数字
			 * 	parseInt()		把字符串转成整数型数字
			 * 	parseFloat()	把字符串转成浮点型（小数）数字
			 * 
			 * 传进来的字符串必须是数字或者空格加数字开头，它会从数字开始，一位一位往后找，直到找到
			 * 的字符不是数字就会停止，会把找到的数字字符转成真正的数字。如果没找到那就返回一个NaN
			 * 
			 * 经常取到属性值value，通常带单位，如果要进行运算，需要去掉单位，就用parseInt()、parseFloat() 
			 * 
			 * * isNaN()
			 * 判断一个值是不是NaN,它会先把参数用Number()方法转一下
			 * 它具有一个功能是用来检测数字的，但是它的本意并不是用来检测数字的，是用来检测NaN的
			 * 
			 * 如果参数的结果为NaN，那它返回一个true
			 * 如果参数的结果不为NaN,那它范湖一个false
			 * 
			 ** 任意类型转字符串
			 * String() 
			 * 
			 ** 任意类型转布尔值
			 * Boolean(要转的值)
			 * 		1、Undefined转布尔值
			 * 			false
			 * 		2、Null
			 * 			false
			 * 		3、Number
			 * 			0、NaN转布尔值的结果为false，其他的转布尔值的结果为true
			 * 		4、String
			 * 			空字符串转布尔值的结果为false,其他的转布尔值的结果为true 
			 * 
			 * * 类型转换分两种
			 * 		1、显式类型转换
			 * 			通过一些方法，很明确 的将某种数据类型转换为另一种数据类型
			 * 			Number()
			 * 			parsInt()
			 * 			parsFloat()
			 * 			String()
			 * 			Boolean()
			 * 		2、隐式类型转换
			 * 			在进行一些操作的时候，根本目的不是做类型转换。但是如果要进行操作的话，那数据必须符合某种累心g.js会在内部对数据行一些转换
			 * 			+  -
			 * 
			 * *算数运算符
			 * + - * / % ++ --
			 * 
			 * ++放后面，先把自己赋给另一个变量，自己再加1
			 * --放后面，先把自己赋给另一个变量，自己再减1
			 * 
			 * ++放前面，先把自己加个1，然后赋值给另一个变量
			 * --放前面，先把自己减个1，然后赋值给另一个变量
			 * 
			 * 赋值运算符
			 * = += -= *= /= %=
			 * 
			 * 关系运算符
			 * > < >= <= == === != !=== 
			 * 字母比较是比较字母的ascii码值
			 * 
			 * 逻辑运算符
			 * && || ！
			 * &&	如果左边与右边的条件同时成立时，整个条件才成立
			 * 		当左边为真的时候，返回右边的值，当左边为假的话，返回左边的值
			 * ||	如果有一个条件成立，整个条件成立
			 * 		当左边为真，返回左边的值。当左边为假，返回右边的值。
			 * ！	取反
			 * 
			 * 三元运算符
			 * 元：操作数
			 * 		一元操作符
			 * 		二元操作符
			 * 		三元操作符
			 * 		a？b：c
			 * 		如果a的值为真，则返回b，如果为假，返回c	
			 * 
			 * 运算符的优先级
			 * 参照c语言的优先级“运算符优先级”
			 * 中括号、小括号、点属于同一级别，他们有最高的优先级
			 * 如果不确定谁先谁后，就给要算的内容加上小括号，提高他的优先级。
			 * 
			 * *流程控制语句
			 * 
			 * switch
			 * 		根据一个变量的值，做不同的事情。
			 * 
			 * 
			 * 语法
			 * 		switch(变量){
			 * 			case 值：
			 * 				当这个值与变量的值相同的时候，才会走这里的代码
			 * 				break;		停止一下代码继续执行
			 * 			case 值：
			 * 				当这个值与变量的值相同的时候，才会走这里的代码
			 * 				break;		停止一下代码继续执行
			 * 			case 值：
			 * 				当这个值与变量的值相同的时候，才会走这里的代码
			 * 				break;		停止一下代码继续执行
			 * 			default:
			 * 				当以上变量都不满足的时候，会执行这里的代码
			 * }
			 * 
			 * 用户注册信息
			 * 
			 * *for语句
			 * 
			 * 语法
			 * 		for(条件初始化；条件判断；条件变化) {
			 * 			需要执行的代码
			 * }；
			 * 		for(条件初始化；条件判断；条件变化) 需要执行的代码；		//精简写法
			 * 
			 * 步骤
			 * 		第一步：条件初始化
			 * 		第二步：条件判断
			 * 		第三步：当条件成立的时候，走大括号里的代码
			 * 		第四步：条件变化
			 * 
			 * 从第二次开始，就不走第一步了，重复走第二、三、四步了
			 * 
			 * *for in语句
			 * 		也是用来循环的，只不过多了一个作用：
			 * 		用来便利对象当中的数据
			 * 语法
			 * 		for(var 变量名 in 对象){
			 * 			变量名		对象里的属性名（key）
			 * 			对象[属性名]		属性名对应的值
			 * }
			 * 
			 * 要取到一个对象里面所有数据，只能用for in方法
			 * 
			 * *while
			 * 		循环，条件循环。只有当条件满足的情况下才会去循环。
			 * 
			 * 语法
			 * 		while(条件语句){
			 * 		当条件满足的时候，会循环执行这里的代码
			 * }
			 * 
			 * //循环一次，条件要变一次
			 * 
			 * var i=0;
			 * while(i<5){
			 * 		console.log(i);
			 * 		i++
			 * }
			 * 
			 * 注意：当while的条件不具备停止条件的时候，一定要在循环体内给以条件变化，否则就是一个死循环
			 * 
			 *for		是一个次数循环
			 * while	是一个条件循环，它一般用在嵌套的元素，或者有嵌套的数据
			 * 
			 * 
			 * 
			 * 要做循环的时候，首先考虑用for（横向），如果for做不出来，那就选择用while（纵向）
			 * 
			 * 
			 *break
			 * 停止循环，剩下的循环就不会走了（break后面的代码时不会执行的）
			 * 
			 * continue
			 * 停止循环，只不过它停止的是当次的循环，后面的循环还是会走。
			 * 当你的循环找到有class的li时，不希望有class的li背景色变色，就用continue跳过
			 * 
			 * return
			 * 返回，让函数停止执行，它只能用在函数内* 
			 * 
			 *  * 函数
			 * 		重复利用代码，把要利用的重复代码放到一个函数当中，在其他需要用到的地方，调用一下就可以
			 *
			 * 语法
			 * 		function 函数名(参数，参数,...,参数) {
			 * 			//在这里可以使用这个参数
			 * 			//这里放要重复利用的代码
			 * }
			 * 
			 * 调用
			 *		函数名(参数，参数,...,参数);		//这样就调用了 
			 * 
			 * 
			 ** 函数类型
			 * 		1、函数声明
			 * 			语法
			 * 				function 函数名(参数) {
			 * 					执行代码
			 * 				}
			 * 			调用
			 * 				1、函数名（参数）
			 * 				2、把函数声明变成函数表达式，在后加一个小括号
			 * 		2、函数表达式
			 * 			语法
			 * 				var 变量=function（参数） {
			 * 						要执行的代码
			 * 				}
			 * 			调用
			 * 				1、变量(参数)
			 * 				2、函数表达式可以直接在后面加上一对小括号，就被调用。
			 * 			注意：
			 * 				1、函数表达式里面的function后面如果有名字的话，在调用的时候是不能拿这个名字去调用
			 * 				2、匿名函数就是函数表达式 
			 * 
			 * 
			 * *函数参数
			 * 		从函数外面向里面传数据，在函数里可以接收到这些数据，并且能够使用它。这些数据就叫参数。
			 * 		参数是放在小括号里，可以放0个或者多个，每个参数用逗号隔开
			 * 
			 * 
			 * 		1、形参
			 * 			形式上的参数，在函数声明的小括号里
			 * 			形参的值是由实参决定的
			 * 		2、实参
			 *			实际的参数，放在函数调用的小括号里
			 * 			实参必须与形参一一对应，在调用的时候，要把实参传够数量。如果有一个实参没有传，那形参的值就是undefined
			 * 
			 * *arguments对象
			 * 		代表了所有的实参集合(类数组)
			 * 		这个集合中的每个数据都有一个自己对应的下标
			 * 		这个集合还有一个length，代表了实参的个数
			 * 		它只能在函数内使用
			 * 
			 * 操作参数对象，使形参个数不受限制
			 * 
			 **函数返回值
			 * 		函数的运算结果
			 * 
			 * return
			 * 		1、返回函数的运算结果
			 * 			return 值
			 * 			如果说函数里有return，那这个函数的返回 结果就是rerurn后面的值（运算后的结果）
			 * 			如果函数里没有retrun，那这个函数的返回结果就是undefined
			 * 		2、阻止函数继续运行 
			 * 
			 * *作用域，作用范围
			 *		只有函数和变量有作用域，以函数来划分，一个函数就是一个作用域
			 *
			 *全局作用域
			 * 		整个文档
			 * 		变量或者函数在函数外面声明，那他们就是全局变量和全局函数
			 * 		全局的作用范围是整个文档，在这个页面任何地方都可以访问到它们。
			 * 
			 * 之所以全局变量在任何地方都可以访问到，是因为全局变量它是window下的属性
			 * window是一个全局对象，它本身在页面中任何位置都可以用，所以说全局变量可以在任何地方用
			 * 
			 * 注意：尽量避免用全局变量
			 * 
			 * 局部作用域
			 * 		函数范围内用
			 * 
			 *一个变量是局部变量，在外面是访问不到的，会报错
			 * 
			 * 
			 * 作用域链规则
			 * 		如果一个函数需要用到一个变量，那它会先在自己的作用域找这个变量，如果有那它就直接使用自己的。
			 * 如果自己没有的话，他就会一层一层往外找，直到找到外面的变量，找到后就用外面的变量。
			 * 
			 * *预解析
			 *		函数或者变量都会有一个预解析的过程，js会把函数或者变量提前解析一下，解析到他们对应的作用域
			 * 最开始的位置
			 * 
			 * 步骤
			 * 		1、先找var、function关键字以及参数
			 * 		2、如果找到了var(声明的变量、函数)，会给它赋值一个undefined值。如果找到function，那它会把整个函数都拿过来
			 * 		3、把找到的东西，放到对应的作用域的最开始的位置
			 * 		4、逐行执行代码
			 * 
			 **函数
			 * 		1、函数声明
			 * 			函数声明可以被预解析，所以可以先调用，在声明
			 * 		2、函数表达式
			 *			不会被预解析，所以只能先声明，再调用，不能把顺序弄反了，不然报错。
			 * 
			 * 
			 * *闭包
			 * 		函数嵌套函数，子函数访问父函数的变量，就产生了一个闭包环境
			 *
			 *垃圾回收机制
			 * 生命周期
			 *
			 * *生命周期
			 *		变量或者函数在相应的作用域里存在的时间
			 * 			局部变量：不再使用了，就是生命周期结束了。局部变量是在函数内声明的，当函数执行完成以后，这个变量就不存在了。
			 * 			全局变量：页面关闭就不存在了
			 * 
			 * 垃圾回收机制
			 * 		变量存在内存当中的，变量在使用完以后，没有在其他的地方再使用，就会被清除，用来释放内存。垃圾回收机制会按照固定的时间
			 * ，周期性的执行。 
			 * 
			 **在外面访问里面的a和fn2
			 * 闭包的作用
			 *  
			 *  *函数自执行
			 * 		函数表达式后面加括号
			 *
			 *闭包的作用
			 * 		在循环当中找到对应的i的值
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 * 
			 */
			
			
			
			
			
			
			
		</script>
	</head>
	<body>
	</body>
</html>
